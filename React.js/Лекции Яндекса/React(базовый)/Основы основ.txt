Весь интерфейс строится из React-элементов!

Виды React-элементов:
    1. React элементы DOM
        React.createElement('span')
    2. React элементы компоненты
        Коробка для React элементов DOM
        Возвращет ReactElement или null

!!!React-элементы это не DOM-элементы!!!

/////////////////

Что такое DOM-элементы? 

Когда браузер загружает html-файл
    он создает иерархическое дерево объектов
    каждый узел этого дерева это DOM-элемент

/////////////////


Всё, что между тегами, это children



--------------- Как React узнает что нужно перерисовать компонент? ---------------

1. Если поменялись props
    а. Если prop это примитив, то просто сравнивает
    б. Если prop это объект, то сравниваются ссылки


Если перерисовался родитель, то перерисовываются все дочерние компоненты




--------------- Почему нельзя хранить состояние в обычных переменных? ---------------

Потому, что изменение переменной -- это не сигнал для перерисовки компонента

Даже если бы при изменение переменной страница бы перерисовывалась, то значение переменной сбрасывалось бы




-------------- Что такое хуки? ---------------

Функции с особыми возможностями

Сколько бы раз не перерисовывался бы компонент, для него будет одно состояние



-------------- Как создать кастомный хук? --------------

1. Создать файл для хука
2. написать хук
3. 


-------------- useCallback --------------

Позволяет делать стабильные ссылки
Стабильная ссылка -- ссылка на функцию, и она всегда с нами одна

useCallback запоминает функцию



------------------ useMemo ------------------ 

useMemo запоминает результат выполнения функции
Принимает функцию и массив зависимостей

Если значения в массиве не изменились, то функция не будет вызвана еще раз при перерисовке компонента


///////////////////////

Когда мы передаем в props массив или объект, 
    то когда мы меняем его, нужно создавать новый

///////////////////////


///////////////////////

Если хотим отрисовать массив данных, 
    нужно использовать map()
    c уникальным ключом key

///////////////////////




------------------ Жизненный цикл компонента ------------------ 

1. Mount
    Первый рендер

2. Update 
    Обновление
    Происходят изменения, компонент живет

3. UnMount
    Удаление



------------------ Зачем нужен атрибут key? ------------------ 

Основная задача -- помочь React идентифицировать, 
                       какие именно элементы в списке были изменены, добавлены или модифицированы

React использует ключи, для эффективного обновления пользовательского интерфейса





------------------ useReducer ------------------ 

Принимает reducer, initialState
Возвращает state, dispatch

dispatch - функция, принимает action
    этот action попадет в reducer и обновит состояние



reducer -- чистая функция, принимает state и action
    обычно выглядит как switch-case по action.type
        есть default случай, должен быть всегда. default должен вызывать состояние без изменений


action - объект  
    поле type -- строка, описывает действие
    поле payload -- информация, чтобы выполнить это действие

state - состояние





------------------ useRef ------------------

создает объект с полем current
Мы можем хранить что, то в этом поле
    т.е подобно состоянию

1. но, когда мы меняем это поле, у нас не будет перерисовки компонента
2. мы можем использовать этот объект для взаимодействия с DOM-элементом



------------------ useEffect ------------------

будет выполнять функцию в зависимости от массива зависимостей

если мы из функции в useEffect вернем другую функцию,
    то эта функция будет вызвана перед следующим вызовом useEffect



------------------ css-модули ------------------

есть библиотека classnames, где через запятую можно указать столько классов сколько захочу

